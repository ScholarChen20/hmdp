# 美食点评

本项目是基于 SpringBoot + Redis + MyBatis Plus 构建的美食服务平台，核心功能覆盖用户登录、下单购物、优惠券秒杀、笔记发布/点赞等场景。技术亮点围绕高并发场景下的性能优化与数据一致性

### 概述美食点评技术栈、核心功能和技术亮点
* 多场景复用Redis：登录黑名单、分布式Session、秒杀库存预扣、点赞排行榜；
* 消息队列削峰：RabbitMQ异步处理秒杀下单，避免DB被瞬时流量压垮；
* 秒杀防超卖方案：Lua脚本原子预扣库存 + 乐观锁扣减DB库存 + Redisson分布式锁实现“一人一单”；
* 实时互动与Feed流：Redis SortedSet实现点赞排行榜，推拉结合模式保障Feed流的实时性与性能；
* 分层架构解耦：三层架构（表现层→服务层→数据层）+ 多级缓存（本地缓存+Redis+DB）提升系统容灾与查询性能。

### Redis实现分布式Session的流程和优势是什么？
1. 用户登录成功生成token → 将token与用户信息以K-V形式存入Redis（设置过期时间）→ 后续请求携带token，服务端从Redis查询用户信息，存在则视为合法会话；
2. 优点：多服务器共享Session，避免Nginx ip_hash 导致的单点故障；Redis读写性能远高于传统Session同步（如Tomcat集群Session复制），适合高并发场景；

### “优惠券秒杀”模块的技术方案是如何设计的？如何应对高并发？
* 库存预扣（Lua脚本）：秒杀前用Lua脚本原子性检查并预扣Redis库存，避免多线程并发抢库存导致超卖；
* 异步下单（RabbitMQ）：预扣成功后，请求进入RabbitMQ队列异步处理，将瞬时高并发“削平”为MQ的匀速消费，保护DB；
* 防超卖（乐观锁）：MQ消费者扣减DB库存时，通过update goods set stock=stock-1 where id=? and stock>0（版本号/库存字段校验），确保最终库存正确；
* 一人一单（Redisson分布式锁）：以user:seckill:goodsId为锁Key，用Redisson可重入锁保证同一用户对同一商品仅能秒杀一次，避免重复下单。

### 为什么用Lua脚本做库存预扣？相比Java操作Redis有何优势？

1. 原子性：Lua脚本保证秒杀前原子性检查并预扣库存，避免多线程并发抢库存导致超卖；

2. 性能：Lua脚本执行效率高，Redis读写性能远高于传统Java操作Redis；减少Java与Redis的网络交互（一次Lua请求代替多次GET/SET），降低高并发下的延迟。


### RabbitMQ在秒杀中起什么作用？消息积压如何处理？
* 异步削峰。秒杀请求先过Redis预扣+Lua校验，通过后发往MQ，立即返回用户“秒杀中”；MQ消费者再异步处理DB下单，将瞬时万级请求分摊为MQ的匀速消费，避免DB被压垮。

* 消息积压处理：MQ消息积压问题，可采用MQ消息轨迹功能查看消息消费情况，可结合RabbitMQ的死信队列转移超时消息，优先处理新请求。

### 实时互动与Feed流的技术方案是什么？Feed流的实时性如何保障？

* 推模式：用户发布笔记时，主动推送给粉丝的“待消费队列”（Redis List或MQ），保证新内容实时触达；

* 拉模式：用户登录时，主动拉取“待消费队列”中的内容，保证用户即时获取最新内容。

* 场景互补：新笔记用“推”保实时性，冷门内容用“拉”减少无效推送，降低系统压力。

### 开发秒杀模块时遇到的最大难点？如何解决的？
* 超卖问题：初期用Java代码操作Redis库存，存在“查库存→扣库存”被并发打断的情况（如库存1，两个请求同时查到1，都扣减导致库存-1）。**改用Lua脚本原子执行库存检查+预扣，从Redis层保证原子性**；

* 性能瓶颈：秒杀请求直接打DB导致连接池打爆。**引入RabbitMQ做异步队列，请求先入MQ**，消费者匀速消费DB，削平瞬时流量；

* 一人多单：初期用Redis SETNX 做锁，但锁超时处理复杂。**改用Redisson分布式锁**，自动续期+可重入，稳定解决重复下单。
